package main

import (
	"fmt"
	"log"
	"os"
	"path"
	"path/filepath"
	"regexp"
	"strconv"
)

const versionInfo = `{
	"FixedFileInfo": {
	  "FileVersion": {
		"Major": %d,
		"Minor": %d,
		"Patch": %d,
		"Build": %d
	  },
	  "ProductVersion": {
		"Major": %d,
		"Minor": %d,
		"Patch": %d,
		"Build": %d
	  }
	},
	"StringFileInfo": {
		"Comments": "",
		"CompanyName": "github.com/evogelsa",
		"FileDescription": "DCS Real Weather Updater",
		"FileVersion": "%d.%d.%d",
		"InternalName": "DCS Real Weather",
		"LegalCopyright": "Copyright 2020 evogelsa",
		"OriginalFilename": "realweather.exe",
		"ProductName": "DCS Real Weather",
		"ProductVersion": "%d.%d.%d.%d"
	},
	"VarFileInfo": {
	  "Translation": {
		  "LangID": "0409",
		  "CharsetID": "0"
	  }
	},
	"IconPath": "%s",
	"ManifestPath": ""
}
`

const meta = `// Code generated by go run generate.go; DO NOT EDIT.

package versioninfo

const (
	Major = %d
	Minor = %d
	Patch = %d
	CommitNum = %d
	Commit = "%s"
	Pre = "%s"
)
`

var re = regexp.MustCompile(`v(?P<Major>\d+)\.(?P<Minor>\d+)\.(?P<Patch>\d+)-?(?P<Pre>(?:alpha)|(?:beta)|(?:rc\d*))?-?(?P<CommitNum>\d*)?.*(?:-g(?P<Commit>\w*))?`)

func main() {
	if !(len(os.Args) > 1) {
		log.Fatalf("Must supply version!")
	}

	gitInfo := os.Args[1]

	match := re.FindStringSubmatch(gitInfo)
	v := make(map[string]string)

	for i, name := range re.SubexpNames() {
		if i != 0 && name != "" {
			v[name] = match[i]
		}
	}
	if len(v) == 0 {
		log.Fatalln("Could not parse version:", gitInfo, match, v)
	}

	major, _ := strconv.Atoi(v["Major"])
	minor, _ := strconv.Atoi(v["Minor"])
	patch, _ := strconv.Atoi(v["Patch"])
	commitNum, _ := strconv.Atoi(v["CommitNum"])
	pre := v["Pre"]
	commit := v["Commit"]

	log.Printf("Major: %d, Minor: %d, Patch: %d, Build: %d, Pre: %s, Commit: %s", major, minor, patch, commitNum, pre, commit)

	versionInfoOut := "versioninfo.json"
	metaOut := "versioninfo.go"
	iconPath := "../../versioninfo/icon.ico"
	versionOut := "version.txt"
	if len(os.Args) > 2 {
		versionInfoOut = filepath.Join(os.Args[2], versionInfoOut)
		metaOut = filepath.Join(os.Args[2], metaOut)
		iconPath = path.Join(os.Args[2], iconPath)
		versionOut = filepath.Join(os.Args[2], versionOut)
	}

	err := os.WriteFile(
		versionInfoOut,
		[]byte(fmt.Sprintf(
			versionInfo,
			major,
			minor,
			patch,
			commitNum,
			major,
			minor,
			patch,
			commitNum,
			major,
			minor,
			patch,
			major,
			minor,
			patch,
			commitNum,
			iconPath,
		)),
		os.ModePerm,
	)
	if err != nil {
		log.Println(err)
	}

	err = os.WriteFile(
		metaOut,
		[]byte(fmt.Sprintf(
			meta,
			major,
			minor,
			patch,
			commitNum,
			commit,
			pre,
		)),
		os.ModePerm,
	)
	if err != nil {
		log.Println(err)
	}

	err = os.WriteFile(
		versionOut,
		[]byte(gitInfo),
		os.ModePerm,
	)
	if err != nil {
		log.Println(err)
	}
}
